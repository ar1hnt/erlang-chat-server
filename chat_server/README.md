# Чат-сервер на Erlang

OTP‑приложение: TCP‑чат с комнатами, мониторингом подключений, частичным восстановлением состояния по нику и простым GUI‑клиентом на Python Tkinter.

## Сборка

```
rebar3 compile
```

## Запуск сервера

```
rebar3 shell
```

Приложение поднимет listener на порту `5555`.

## Клиент (telnet)

```
telnet localhost 5555
```

Команды:

- `/nick NAME` — установить ник; при повторном входе с тем же ником восстановятся комнаты
- `/join ROOM` — вступить в комнату и сделать её активной
- `/leave ROOM` — выйти из комнаты (если это активная — вернёт в `main`)
- `/help` — показать команды

Обычные сообщения отправляются в активную комнату. Свои сообщения помечаются как `You: ...`, сообщения других — как `[room] ...`.

Кириллица поддерживается (UTF‑8).

## GUI‑клиент (Python + Tkinter)

Требуется Python 3 с Tkinter. В отдельном терминале:

```
python3 clients/python/tk_chat_client.py
```

Клиент запросит ник и подключится к `localhost:5555`. На разрыв соединения пытается переподключиться и отправляет `/nick` после восстановления.

## Распределённый режим (несколько нод)

Можно запускать несколько нод Erlang и объединять их в кластер (общая cookie):

```
erl -name a@127.0.0.1 -setcookie chat
erl -name b@127.0.0.1 -setcookie chat
```

На каждой ноде загрузите приложение, затем проверьте связь:

```
net_adm:ping('b@127.0.0.1').
```

Рассылка сообщений выполняется на всех нодах (используется `abcast` в `room_manager`).

## Структура OTP

- `chat_app` — application behaviour, стартует `chat_sup`.
- `chat_sup` — корневой супервизор: `room_manager`, `client_sup`, `listener`.
- `client_sup` — динамический супервизор клиентов (simple_one_for_one).
- `listener` — TCP‑listener, принимает соединения, передаёт сокет клиентскому процессу.
- `client_proc` — процесс клиента: приём команд/сообщений, echo, отправка в `room_manager`.
- `room_manager` — комнаты, мониторинг клиентов, хранение никнеймов и комнат для восстановления, распределённая рассылка.

## Примечания

- По умолчанию активная комната — `main`.
- Для полноценного failover между нодами (master/standby) можно расширить схему с использованием `global` и takeover.
